# -*- coding: utf-8 -*-
# Copyright (c) 2021 Contributors as noted in the AUTHORS file
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# System imports
import functools
import importlib
import logging
from abc import ABCMeta
from functools import lru_cache

# Third-party imports
from qtpy.QtCore import QObject

# Local imports


_logger = logging.getLogger(__name__)


class SingletonMeta(type):
    '''
    Uses like this:
    > class YourClass(metaclass=SingletonMeta):
    >     ...
    '''

    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)

        return cls._instances[cls]


def MetaClassResolver(*subclasses, extra_metas=None):
    '''Function to be called as a subclass definition, passing it all the subclasses you actually
    want, plus some extra metaclasses if you need.
    It will create a composite metaclass made of the metaclasses of all subclasses.

    Usage:
    class MyClass(MetaClassResolver(APythonSubClass, AQtSubclass)):
        ...

    Useful to fix the following error when you mix up Python and Qt subclasses:
      > TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict)
      > subclass of the metaclasses of all its bases
    Or:
      > TypeError: Shiboken.ObjectType.__new__(_ResolverMeta) is not safe,
      > use type.__new__()

    Can also be used to quickly declare several metaclasses:
    class MyClass(MetaClassResolver(extra_metas=[ABCMeta, SingletonMeta])):
        ...
    '''
    # Main principle of a metaclass resolver is to generate
    # a dynamic metaclass subclassing all metaclasses of the subclasses
    # we are interested to have.
    #
    # class _ResolverMeta(metaclass1, metaclass2, ...): ...
    # class _Resolver(subclass1, subclass2, ..., metaclass=_ResolverMeta): ...

    if extra_metas is None:
        extra_metas = []
    extra_metas = list(extra_metas)

    all_metas = [type(subclass) for subclass in subclasses] + extra_metas
    all_metas = list(dict.fromkeys(all_metas))  # Uniquify, keeping order

    # Ensure type is last
    if type in all_metas:
        all_metas.remove(type)
    all_metas.append(type)

    qobj_tp = type(QObject)
    if qobj_tp in all_metas:
        # Solves for PySide6 no longer accepting easily to derive
        # metaclasses from their own metaclass.
        # See PYSIDE-1434 and PYSIDE-1767

        # First, we remove the QObject type from list of metas
        # because we will be manipulating how it finds it.
        # That also means with this solution, the type(QObject) can't be in one
        # particular, user-defined order in the metaclass MRO.
        # But usually that's fine for most cases.
        all_metas.remove(qobj_tp)

        # We construct a class that starts with the QObject type
        # and then list all the other metas.
        # When you instantiate such class, the __new__ of QObject type
        # will be happy to be called as it expects it
        # (ie. avoiding the "... is not safe, use type.__new__...").
        # It will also solve the infamous "the metaclass of a derived class must be..."
        # because the created class will indeed have a metaclass made of
        # all the metaclasses of its subclasses.
        # However, QObject type will not call super().__new__! So, other metaclasses
        # after it never get to execute their new, if you only do that.
        class _QObjectResolver(qobj_tp, *all_metas):
            ...

        # Next, to solve for the other metaclasses __new__ not being called,
        # the solution is to have them be called first (ie. as if QObject type
        # was last in the metaclass MRO). But then you have to intercept
        # the last super().__new__ just before QObject type __new__ gets called
        # (to avoid the "... is not safe, use type.__new__()").
        # And instead swap it with a call to our _QObjectResolver above.
        # The true object will effectively be generated by it. And it will be
        # returned-percolated back up the chain of the other metaclasses __new__.
        class _QObjectInterceptor(qobj_tp):
            def __new__(cls, *args, **kwargs):
                return super().__new__(_QObjectResolver, *args, **kwargs)

        # Now we can register our __new__ interceptor as the (almost) last
        # class in the list of metaclasses, and construct a metaclass resolver
        # just like if it was a simple resolution case.
        all_metas.insert(-1, _QObjectInterceptor)  # Insert before type-class

        # The magic in this method is to execute both:
        # - The other metaclasses __new__, such that their behaviour is kept (eg. ABCMeta init)
        # - The QObject type __new__ as if it was alone (and be the one creating the real object)
        # And still make Python believes the final "hybrid" metaclass is
        # actually made up of all the subclasses metaclasses.

        # One last trick below though...

    class _ResolverMeta(*all_metas):
        pass

    class _Resolver(*subclasses, metaclass=_ResolverMeta):

        def __new__(cls, *args, **kwargs):
            obj = super().__new__(cls, *args, **kwargs)
            if (ABCMeta in all_metas) and obj.__abstractmethods__:
                # In case an ABC is used along a QObject, it turns out
                # the new of QObject is not checking for abstract methods.
                # Therefore, even if ABCMeta.__new__ has properly run and
                # inited its internal states, the actual check for abstraction
                # is not enforced.
                # Therefore, we kind of replicate it here, raising the TypeError ourselves.
                # In the event we are an ABC but not a QObject, and we
                # do have abstract methods, the normal abstraction check will happen
                # before we reach this one.
                raise TypeError(
                    f'Can\'t instantiate abstract class {cls.__name__} '
                    f'with abstract methods {", ".join(obj.__abstractmethods__)}'
                )
            return obj

        pass

    return _Resolver


def dig_wrapped(cls):
    while hasattr(cls, '__wrapped__'):
        cls = cls.__wrapped__
    return cls


def class_decorator(cls):
    '''A utility to act as a class decorator. To be returned by a callable decorator.'''
    return cls


def class_decorator_ext(callback):
    '''Another helper for callable decorator, this time allowing to specify a callback to which we
    will pass the actual decorated class.'''
    def class_decorator(cls):
        callback(dig_wrapped(cls))

        @functools.wraps(cls)
        def wrapper(*args, **kwargs):
            return cls(*args, **kwargs)
        return wrapper

    return class_decorator


@lru_cache(maxsize=None)
def class_loader(fqname):
    _logger.info('Loading class %s', fqname)
    module_path, qualname = fqname.split(':')
    module = importlib.import_module(module_path)
    attr = module
    for attr_name in qualname.split('.'):
        attr = getattr(dig_wrapped(attr), attr_name)
    return attr
